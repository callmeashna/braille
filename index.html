<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Enhanced Braille Code — Learn, Encode & Decode (UEB)</title>
<meta name="description" content="Comprehensive UEB Braille tool with expanded contractions, learning mode, file import/export, and advanced features."/>
<style>
  :root{
    --bg:#0f1222; --fg:#e8ecf8; --muted:#9fb0d9; --card:#151939; --accent:#7aa2ff;
    --dot:#2a315f; --dot-active:#e8ecf8; --focus:#ffd166; --danger:#ff476f; --success:#4ade80;
    --warning:#f59e0b; --radius:16px; --dot-size:18px;
  }
  [data-contrast="high"]{
    --bg:#000; --fg:#fff; --muted:#ddd; --card:#111; --accent:#0ff;
    --dot:#333; --dot-active:#fff; --focus:#ff0; --danger:#f00; --success:#0f0; --warning:#fa0;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--fg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Arial;
    line-height:1.4;
  }
  .wrap{max-width:1200px; margin:auto; padding:24px; display:grid; gap:16px}
  header{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  h1{font-size:clamp(20px,3vw,28px); margin:0}
  .controls{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .btn, select, input[type="range"], input[type="file"]{
    background:var(--card); color:var(--fg); border:1px solid #2a2e55; border-radius:999px;
    padding:10px 14px; cursor:pointer; font-size:14px;
  }
  .btn:focus, select:focus, .kbd:focus, textarea:focus, input:focus { 
    outline:3px solid var(--focus); outline-offset:2px 
  }
  .btn:hover{border-color:var(--accent)}
  .btn.success{background:var(--success); color:#000}
  .btn.warning{background:var(--warning); color:#000}
  .btn.danger{background:var(--danger); color:#fff}
  .grid{display:grid; gap:16px}
  .cols{display:grid; grid-template-columns:1fr; gap:16px}
  @media(min-width:900px){ .cols{ grid-template-columns:1fr 1fr } }
  .card{background:var(--card); border:1px solid #24264a; border-radius:var(--radius); padding:16px}
  .label{display:flex; justify-content:space-between; align-items:center; color:var(--muted); font-size:13px; margin-bottom:8px}
  textarea, input[type="text"]{
    width:100%; min-height:160px; resize:vertical; background:#0e1230; color:var(--fg);
    border:1px solid #2a2e55; border-radius:12px; padding:12px; font-size:15px
  }
  input[type="text"]{min-height:auto; height:40px}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}
  .braille-out{
    font-size:28px; line-height:1.6; word-wrap:break-word; overflow-wrap:anywhere; background:#0e1230;
    padding:12px; border:1px solid #2a2e55; border-radius:12px; min-height:160px; position:relative;
  }
  .stats{position:absolute; top:8px; right:8px; background:var(--card); padding:4px 8px; border-radius:8px; font-size:11px; color:var(--muted)}
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .hint{color:var(--muted); font-size:12px}
  .pill{background:#0e1230; border:1px solid #2a2e55; border-radius:999px; padding:6px 10px; font-size:12px}
  .kbd{display:inline-flex; align-items:center; justify-content:center; min-width:28px; min-height:28px; border-radius:8px;
       background:#0e1230; border:1px solid #2a2e55; color:var(--fg); text-align:center; font-size:13px}
  .error{color:var(--danger); font-size:12px; margin-top:4px}
  .success-msg{color:var(--success); font-size:12px; margin-top:4px}
  
  /* Tabs */
  .tabs{display:flex; gap:4px; margin-bottom:16px; border-bottom:1px solid #2a2e55}
  .tab{background:transparent; border:none; color:var(--muted); padding:12px 16px; cursor:pointer; border-radius:8px 8px 0 0}
  .tab.active{background:var(--card); color:var(--fg); border-bottom:2px solid var(--accent)}
  
  /* Virtual 6-dot cell */
  .cell{
    display:grid; grid-template-columns:repeat(2,1fr); gap:12px; align-items:center; justify-items:center;
    width:max-content; padding:16px; border-radius:16px; background:#0e1230; border:1px solid #2a2e55
  }
  .dot{
    width:var(--dot-size); height:var(--dot-size); border-radius:999px; background:var(--dot);
    border:1px solid #3a3f73; cursor:pointer; position:relative; transition:all 0.2s;
  }
  .dot[aria-pressed="true"]{ background:var(--dot-active); transform:scale(1.1) }
  .dot:hover{transform:scale(1.05)}
  .dot::after{
    content:attr(data-n); position:absolute; top:-18px; left:50%; transform:translateX(-50%);
    font-size:11px; color:var(--muted)
  }
  
  /* Learning mode */
  .learning-panel{background:#0e1230; border:1px solid #2a2e55; border-radius:12px; padding:16px; margin-top:16px}
  .contraction{background:rgba(122,162,255,0.2); border-radius:4px; padding:2px 4px; cursor:help; position:relative}
  .contraction:hover::after{
    content:attr(data-desc); position:absolute; top:100%; left:0; background:var(--card);
    color:var(--fg); padding:4px 8px; border-radius:4px; font-size:11px; white-space:nowrap; z-index:10;
    border:1px solid #2a2e55;
  }
  
  /* Modal */
  .modal{position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:100; display:none}
  .modal.show{display:flex; align-items:center; justify-content:center}
  .modal-content{background:var(--card); border-radius:var(--radius); padding:24px; max-width:600px; width:90%; max-height:80vh; overflow-y:auto}
  .modal-header{display:flex; justify-content:space-between; align-items:center; margin-bottom:16px}
  .modal-close{background:none; border:none; color:var(--fg); font-size:24px; cursor:pointer}
  
  .big{ font-size: clamp(28px, 4vw, 40px) }
  .live{ position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden }
  footer{ color:var(--muted); font-size:12px; text-align:center; padding:8px 0 }
  
  .reference-grid{display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:8px}
  .ref-item{display:flex; align-items:center; gap:8px; padding:4px; border-radius:4px; background:#0e1230}
</style>
</head>
<body>
<div class="wrap" id="app">
  <header>
    <h1 class="big">Enhanced Braille Code</h1>
    <div class="controls" role="group" aria-label="Display controls">
      <button class="btn" id="contrastBtn" aria-pressed="false" title="Toggle high contrast">High Contrast</button>
      <label class="pill" for="sizeRange">Dot size
        <input id="sizeRange" type="range" min="14" max="36" value="18" aria-label="Adjust dot size">
      </label>
      <label class="pill">Grade
        <select id="mode">
          <option value="g1">UEB Grade-1 (letters)</option>
          <option value="nums">Grade-1 + numbers</option>
          <option value="g2">UEB Grade-2 (contractions)</option>
        </select>
      </label>
      <button class="btn" id="helpBtn">Help</button>
      <button class="btn" id="learningToggle">Learning Mode</button>
    </div>
  </header>

  <!-- Tabs -->
  <div class="tabs">
    <button class="tab active" data-tab="converter">Converter</button>
    <button class="tab" data-tab="composer">Cell Composer</button>
    <button class="tab" data-tab="reference">Reference</button>
  </div>

  <!-- Converter Tab -->
  <div id="tab-converter" class="tab-content">
    <section class="grid cols" aria-label="Encoder and decoder">
      <!-- Encoder -->
      <div class="card">
        <div class="label">
          <strong>Text → Braille</strong>
          <span class="hint">Type or paste text</span>
        </div>
        <textarea id="plainIn" class="mono" placeholder="Type here... e.g., The quick brown fox"></textarea>
        <div class="row" style="margin-top:8px">
          <button id="copyBraille" class="btn" title="Copy Braille to clipboard">Copy</button>
          <input type="file" id="importFile" accept=".txt,.brl" style="display:none">
          <button id="importBtn" class="btn" title="Import file">Import</button>
          <button id="exportBtn" class="btn" title="Export Braille">Export</button>
          <button id="clearText" class="btn" title="Clear text">Clear</button>
        </div>
        <div id="textError" class="error" style="display:none"></div>
        <div class="braille-out" id="brailleOut" role="region" aria-live="polite">
          <div class="stats" id="brailleStats">0 chars</div>
        </div>
        <div id="learningText" class="learning-panel" style="display:none">
          <h4>Analysis:</h4>
          <div id="analysisContent"></div>
        </div>
      </div>

      <!-- Decoder -->
      <div class="card">
        <div class="label">
          <strong>Braille → Text</strong>
          <span class="hint">Paste Unicode Braille</span>
        </div>
        <textarea id="brailleIn" class="mono" placeholder="⠓⠑⠇⠇⠕ ⠺⠕⠗⠇⠙"></textarea>
        <div class="row" style="margin-top:8px">
          <button id="copyPlain" class="btn" title="Copy text">Copy</button>
          <button id="validateBraille" class="btn" title="Validate">Validate</button>
          <button id="clearBraille" class="btn" title="Clear">Clear</button>
        </div>
        <div id="brailleError" class="error" style="display:none"></div>
        <div id="brailleSuccess" class="success-msg" style="display:none"></div>
        <textarea id="plainOut" class="mono" placeholder="Decoded text appears here..." readonly></textarea>
        <div class="stats" id="plainStats">0 chars</div>
      </div>
    </section>
  </div>

  <!-- Cell Composer Tab -->
  <div id="tab-composer" class="tab-content" style="display:none">
    <section class="card">
      <div class="label">
        <strong>Compose Braille Cell</strong>
        <span class="hint">Click dots or use keys 1-6</span>
      </div>
      <div class="row" style="align-items:flex-start">
        <div class="cell" id="cell">
          <button class="dot" data-bit="1" data-n="1" aria-pressed="false" aria-label="Dot 1"></button>
          <button class="dot" data-bit="8" data-n="4" aria-pressed="false" aria-label="Dot 4"></button>
          <button class="dot" data-bit="2" data-n="2" aria-pressed="false" aria-label="Dot 2"></button>
          <button class="dot" data-bit="16" data-n="5" aria-pressed="false" aria-label="Dot 5"></button>
          <button class="dot" data-bit="4" data-n="3" aria-pressed="false" aria-label="Dot 3"></button>
          <button class="dot" data-bit="32" data-n="6" aria-pressed="false" aria-label="Dot 6"></button>
        </div>
        <div>
          <div class="label" style="margin-top:0"><span>Current cell</span></div>
          <div id="cellGlyph" class="braille-out" style="min-width:80px; text-align:center; font-size:40px"> </div>
          <div id="cellMeaning" class="hint" style="text-align:center; margin-top:8px"></div>
          <div class="row" style="margin-top:12px; justify-content:center">
            <button class="btn" id="insertToPlain">→ Text</button>
            <button class="btn" id="insertToBraille">→ Braille</button>
            <button class="btn" id="clearCell">Clear</button>
          </div>
        </div>
      </div>
    </section>
  </div>

  <!-- Reference Tab -->
  <div id="tab-reference" class="tab-content" style="display:none">
    <div class="grid">
      <div class="card">
        <h3>Grade-2 Contractions</h3>
        <div class="cols">
          <div>
            <h4>Whole Words</h4>
            <div id="wordSignsList" class="reference-grid"></div>
          </div>
          <div>
            <h4>Letter Groups</h4>
            <div id="groupSignsList" class="reference-grid"></div>
          </div>
        </div>
      </div>
      <div class="card">
        <h3>Alphabet</h3>
        <div id="alphabetChart" class="reference-grid"></div>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <div id="helpModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Keyboard Shortcuts</h3>
        <button class="modal-close" id="closeHelp">&times;</button>
      </div>
      <div>
        <p><kbd>Ctrl+B</kbd> Copy Braille</p>
        <p><kbd>Ctrl+T</kbd> Copy Text</p>
        <p><kbd>Ctrl+I</kbd> Import File</p>
        <p><kbd>Ctrl+E</kbd> Export</p>
        <p><kbd>1-6</kbd> Toggle cell dots</p>
        <p><kbd>Enter</kbd> Insert cell</p>
        <p><kbd>Backspace</kbd> Clear cell</p>
      </div>
    </div>
  </div>

  <footer>Enhanced with expanded contractions, learning mode, file I/O, and validation.</footer>
  <div id="live" class="live" aria-live="polite"></div>
</div>

<script>
// Braille utilities
const U_BASE = 0x2800;
const bitsToChar = bits => String.fromCodePoint(U_BASE + bits);
const charToBits = ch => (ch.codePointAt(0) - U_BASE);
const DOTS = (...arr) => arr.reduce((a,b)=>a|({1:1,2:2,3:4,4:8,5:16,6:32}[b]||0),0);

// Grade-1 alphabet mapping
const mapAtoBrailleBits = {
  a:1, b:3, c:9, d:25, e:17, f:11, g:27, h:19, i:10, j:26,
  k:5, l:7, m:13, n:29, o:21, p:15, q:31, r:23, s:14, t:30,
  u:37, v:39, w:58, x:45, y:61, z:53,
  ' ':0,
  '.':46, ',':2, ';':6, ':':18, '!':22, '?':38, "'":4, '-':36, '/':12,
  '(': 55, ')': 62, '"': 16, '#': 60
};

// Reverse lookup
const bitsToChar1 = {};
Object.entries(mapAtoBrailleBits).forEach(([k,v]) => bitsToChar1[v] = k);

// Enhanced Grade-2 contractions
const CONTRACTIONS = {
  wordsigns: [
    {word: 'and', bits: 31, desc: 'whole word and'},
    {word: 'for', bits: 63, desc: 'whole word for'},
    {word: 'of', bits: 55, desc: 'whole word of'},
    {word: 'the', bits: 46, desc: 'whole word the'},
    {word: 'with', bits: 62, desc: 'whole word with'},
    {word: 'to', bits: 22, desc: 'whole word to'},
    {word: 'be', bits: 6, desc: 'whole word be'},
    {word: 'his', bits: 38, desc: 'whole word his'},
    {word: 'in', bits: 20, desc: 'whole word in'},
    {word: 'was', bits: 52, desc: 'whole word was'}
  ],
  groupsigns: [
    {seq: 'ch', bits: 33, desc: 'ch sound'},
    {seq: 'sh', bits: 41, desc: 'sh sound'},
    {seq: 'th', bits: 57, desc: 'th sound'},
    {seq: 'wh', bits: 49, desc: 'wh sound'},
    {seq: 'ou', bits: 35, desc: 'ou sound'},
    {seq: 'st', bits: 12, desc: 'st letters'},
    {seq: 'ing', bits: 44, desc: 'ing ending'},
    {seq: 'er', bits: 59, desc: 'er ending'},
    {seq: 'ed', bits: 43, desc: 'ed ending'},
    {seq: 'ar', bits: 28, desc: 'ar sound'},
    {seq: 'en', bits: 34, desc: 'en letters'},
    {seq: 'in', bits: 20, desc: 'in letters'}
  ]
};

// Build lookup maps
const wordByGlyph = new Map();
const glyphByWord = new Map();
const groupByGlyph = new Map();
const glyphByGroup = new Map();

CONTRACTIONS.wordsigns.forEach(c => {
  const glyph = bitsToChar(c.bits);
  wordByGlyph.set(glyph, c);
  glyphByWord.set(c.word.toLowerCase(), c);
});

CONTRACTIONS.groupsigns.forEach(c => {
  const glyph = bitsToChar(c.bits);
  groupByGlyph.set(glyph, c);
  glyphByGroup.set(c.seq, c);
});

// Encoding functions
function encodeChar(ch) {
  const lower = ch.toLowerCase();
  const bits = mapAtoBrailleBits[lower];
  if (bits === undefined) return ch;
  
  if (/[A-Z]/.test(ch)) {
    return bitsToChar(32) + bitsToChar(bits); // Capital indicator + letter
  }
  return bitsToChar(bits);
}

function encodeText(text, mode = 'g1') {
  if (!text) return '';
  
  const words = text.split(/(\s+)/);
  const result = [];
  
  for (const word of words) {
    if (/^\s+$/.test(word)) {
      result.push(word);
      continue;
    }
    
    if (mode === 'g2') {
      // Check for whole-word contractions
      const lower = word.toLowerCase().replace(/[^a-z]/g, '');
      const contraction = glyphByWord.get(lower);
      
      if (contraction) {
        let encoded = contraction.bits;
        if (/^[A-Z]/.test(word)) {
          result.push(bitsToChar(32) + bitsToChar(encoded));
        } else {
          result.push(bitsToChar(encoded));
        }
        continue;
      }
      
      // Apply group signs
      let remaining = lower;
      let encoded = '';
      
      while (remaining.length > 0) {
        let matched = false;
        
        // Try longest group signs first
        const groups = [...glyphByGroup.keys()].sort((a,b) => b.length - a.length);
        for (const group of groups) {
          if (remaining.startsWith(group)) {
            const contraction = glyphByGroup.get(group);
            encoded += bitsToChar(contraction.bits);
            remaining = remaining.substring(group.length);
            matched = true;
            break;
          }
        }
        
        if (!matched) {
          encoded += encodeChar(remaining[0]);
          remaining = remaining.substring(1);
        }
      }
      
      if (/^[A-Z]/.test(word)) {
        encoded = bitsToChar(32) + encoded;
      }
      result.push(encoded);
    } else if (mode === 'nums') {
      // Number mode
      const withNumbers = word.replace(/\d+/g, (digits) => {
        let numStr = bitsToChar(60); // Number sign
        for (const digit of digits) {
          const letterMap = {'0':'j','1':'a','2':'b','3':'c','4':'d','5':'e','6':'f','7':'g','8':'h','9':'i'};
          numStr += bitsToChar(mapAtoBrailleBits[letterMap[digit]]);
        }
        return numStr;
      });
      result.push(withNumbers.split('').map(encodeChar).join(''));
    } else {
      // Grade 1
      result.push(word.split('').map(encodeChar).join(''));
    }
  }
  
  return result.join('');
}

// Decoding functions
function decodeText(brailleText) {
  if (!brailleText) return '';
  
  let result = '';
  let numberMode = false;
  let capsNext = false;
  
  for (const char of brailleText) {
    const codePoint = char.codePointAt(0);
    
    if (codePoint < 0x2800 || codePoint > 0x28FF) {
      result += char;
      if (/\s/.test(char)) numberMode = false;
      continue;
    }
    
    const bits = codePoint - U_BASE;
    
    // Capital indicator
    if (bits === 32) {
      capsNext = true;
      continue;
    }
    
    // Number indicator
    if (bits === 60) {
      numberMode = true;
      continue;
    }
    
    // Check contractions
    const wordSign = wordByGlyph.get(char);
    if (wordSign) {
      const word = wordSign.word;
      result += capsNext ? word.charAt(0).toUpperCase() + word.slice(1) : word;
      capsNext = false;
      numberMode = false;
      continue;
    }
    
    const groupSign = groupByGlyph.get(char);
    if (groupSign) {
      const seq = groupSign.seq;
      result += capsNext ? seq.charAt(0).toUpperCase() + seq.slice(1) : seq;
      capsNext = false;
      continue;
    }
    
    // Regular character
    if (numberMode) {
      const digitMap = {1:'1',3:'2',9:'3',25:'4',17:'5',11:'6',27:'7',19:'8',10:'9',26:'0'};
      const digit = digitMap[bits];
      if (digit) {
        result += digit;
        continue;
      }
    }
    
    const plainChar = bitsToChar1[bits];
    if (plainChar) {
      result += capsNext ? plainChar.toUpperCase() : plainChar;
    } else {
      result += char;
    }
    
    capsNext = false;
    if (plainChar === ' ') numberMode = false;
  }
  
  return result;
}

// DOM elements
const plainIn = document.getElementById('plainIn');
const brailleOut = document.getElementById('brailleOut');
const brailleIn = document.getElementById('brailleIn');
const plainOut = document.getElementById('plainOut');
const modeSelect = document.getElementById('mode');
const live = document.getElementById('live');

// State
let learningMode = false;

// Update functions
function updateBrailleOutput() {
  const text = plainIn.value;
  const mode = modeSelect.value;
  const encoded = encodeText(text, mode);
  
  brailleOut.textContent = encoded;
  
  const stats = document.getElementById('brailleStats');
  stats.textContent = `${text.length} chars → ${encoded.length} cells`;
  
  if (learningMode) {
    updateLearningAnalysis(text, encoded, mode);
  }
}

function updatePlainOutput() {
  const braille = brailleIn.value;
  const decoded = decodeText(braille);
  plainOut.value = decoded;
  
  const stats = document.getElementById('plainStats');
  stats.textContent = `${decoded.length} chars`;
}

function updateLearningAnalysis(text, braille, mode) {
  const panel = document.getElementById('learningText');
  const content = document.getElementById('analysisContent');
  
  if (mode === 'g2' && text.trim()) {
    panel.style.display = 'block';
    
    const words = text.split(/\s+/).filter(w => w.length > 0);
    const analysis = [];
    
    for (const word of words) {
      const lower = word.toLowerCase().replace(/[^a-z]/g, '');
      const contraction = glyphByWord.get(lower);
      
      if (contraction) {
        analysis.push(`<span class="contraction" data-desc="${contraction.desc}">${word}</span> → ${bitsToChar(contraction.bits)}`);
      } else {
        analysis.push(`${word} → letter by letter`);
      }
    }
    
    content.innerHTML = analysis.join('<br>');
  } else {
    panel.style.display = 'none';
  }
}

// Event listeners
plainIn.addEventListener('input', updateBrailleOutput);
brailleIn.addEventListener('input', updatePlainOutput);
modeSelect.addEventListener('change', updateBrailleOutput);

// Copy functions
document.getElementById('copyBraille').addEventListener('click', async () => {
  try {
    await navigator.clipboard.writeText(brailleOut.textContent);
    live.textContent = 'Braille copied!';
  } catch (e) {
    live.textContent = 'Copy failed';
  }
});

document.getElementById('copyPlain').addEventListener('click', async () => {
  try {
    await navigator.clipboard.writeText(plainOut.value);
    live.textContent = 'Text copied!';
  } catch (e) {
    live.textContent = 'Copy failed';
  }
});

// Learning mode toggle
document.getElementById('learningToggle').addEventListener('click', () => {
  learningMode = !learningMode;
  const btn = document.getElementById('learningToggle');
  btn.textContent = learningMode ? 'Learning: ON' : 'Learning Mode';
  btn.classList.toggle('success', learningMode);
  updateBrailleOutput();
});

// Clear functions
document.getElementById('clearText').addEventListener('click', () => {
  plainIn.value = '';
  updateBrailleOutput();
});

document.getElementById('clearBraille').addEventListener('click', () => {
  brailleIn.value = '';
  updatePlainOutput();
});

// File operations
document.getElementById('importBtn').addEventListener('click', () => {
  document.getElementById('importFile').click();
});

document.getElementById('importFile').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = (event) => {
    plainIn.value = event.target.result;
    updateBrailleOutput();
    live.textContent = 'File imported!';
  };
  reader.readAsText(file);
});

document.getElementById('exportBtn').addEventListener('click', () => {
  const braille = brailleOut.textContent;
  const blob = new Blob([braille], {type: 'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'braille_output.brl';
  a.click();
  URL.revokeObjectURL(url);
  live.textContent = 'File exported!';
});

// Validation
document.getElementById('validateBraille').addEventListener('click', () => {
  const braille = brailleIn.value;
  const errorEl = document.getElementById('brailleError');
  const successEl = document.getElementById('brailleSuccess');
  
  errorEl.style.display = 'none';
  successEl.style.display = 'none';
  
  if (!braille.trim()) {
    errorEl.textContent = 'No Braille text to validate';
    errorEl.style.display = 'block';
    return;
  }
  
  let invalidChars = [];
  for (const char of braille) {
    const cp = char.codePointAt(0);
    if (cp < 0x2800 || cp > 0x28FF) {
      if (!/\s/.test(char)) {
        invalidChars.push(char);
      }
    }
  }
  
  if (invalidChars.length > 0) {
    errorEl.textContent = `Invalid characters found: ${[...new Set(invalidChars)].join(', ')}`;
    errorEl.style.display = 'block';
  } else {
    successEl.textContent = 'Valid Braille text ✓';
    successEl.style.display = 'block';
  }
});

// Tabs functionality
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    const targetTab = tab.getAttribute('data-tab');
    
    // Update active tab
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    
    // Show/hide content
    document.querySelectorAll('.tab-content').forEach(content => {
      content.style.display = 'none';
    });
    document.getElementById(`tab-${targetTab}`).style.display = 'block';
    
    // Initialize reference tab content if needed
    if (targetTab === 'reference') {
      initializeReference();
    }
  });
});

// Cell composer functionality
const cellEl = document.getElementById('cell');
const cellGlyph = document.getElementById('cellGlyph');
const cellMeaning = document.getElementById('cellMeaning');
const dotBtns = [...cellEl.querySelectorAll('.dot')];

function getCurrentCellBits() {
  return dotBtns.reduce((acc, btn) => {
    return acc | (btn.getAttribute('aria-pressed') === 'true' ? Number(btn.dataset.bit) : 0);
  }, 0);
}

function updateCellDisplay() {
  const bits = getCurrentCellBits();
  const glyph = bitsToChar(bits);
  cellGlyph.textContent = glyph || ' ';
  
  // Find meaning
  let meaning = '';
  const plainChar = bitsToChar1[bits];
  if (plainChar) {
    meaning = `Letter: ${plainChar}`;
  } else {
    const wordSign = wordByGlyph.get(glyph);
    const groupSign = groupByGlyph.get(glyph);
    if (wordSign) {
      meaning = wordSign.desc;
    } else if (groupSign) {
      meaning = groupSign.desc;
    } else if (bits === 32) {
      meaning = 'Capital indicator';
    } else if (bits === 60) {
      meaning = 'Number indicator';
    } else {
      meaning = bits === 0 ? 'Space' : 'Unknown pattern';
    }
  }
  cellMeaning.textContent = meaning;
}

function clearCell() {
  dotBtns.forEach(btn => btn.setAttribute('aria-pressed', 'false'));
  updateCellDisplay();
}

// Dot button clicks
dotBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    const pressed = btn.getAttribute('aria-pressed') === 'true';
    btn.setAttribute('aria-pressed', String(!pressed));
    updateCellDisplay();
  });
});

// Cell composer controls
document.getElementById('clearCell').addEventListener('click', clearCell);

document.getElementById('insertToBraille').addEventListener('click', () => {
  const glyph = cellGlyph.textContent.trim();
  if (glyph && glyph !== ' ') {
    const start = brailleIn.selectionStart;
    const end = brailleIn.selectionEnd;
    const value = brailleIn.value;
    brailleIn.value = value.slice(0, start) + glyph + value.slice(end);
    brailleIn.focus();
    brailleIn.selectionStart = brailleIn.selectionEnd = start + 1;
    updatePlainOutput();
  }
});

document.getElementById('insertToPlain').addEventListener('click', () => {
  const bits = getCurrentCellBits();
  const decoded = decodeText(bitsToChar(bits));
  if (decoded && decoded !== bitsToChar(bits)) {
    const start = plainIn.selectionStart;
    const end = plainIn.selectionEnd;
    const value = plainIn.value;
    plainIn.value = value.slice(0, start) + decoded + value.slice(end);
    plainIn.focus();
    plainIn.selectionStart = plainIn.selectionEnd = start + decoded.length;
    updateBrailleOutput();
  }
});

// Initialize reference content
function initializeReference() {
  const wordsList = document.getElementById('wordSignsList');
  const groupsList = document.getElementById('groupSignsList');
  const alphabetChart = document.getElementById('alphabetChart');
  
  if (wordsList.innerHTML === '') {
    // Word signs
    CONTRACTIONS.wordsigns.forEach(c => {
      const div = document.createElement('div');
      div.className = 'ref-item';
      div.innerHTML = `<span style="font-size:20px">${bitsToChar(c.bits)}</span> <span>${c.word}</span>`;
      wordsList.appendChild(div);
    });
    
    // Group signs
    CONTRACTIONS.groupsigns.forEach(c => {
      const div = document.createElement('div');
      div.className = 'ref-item';
      div.innerHTML = `<span style="font-size:20px">${bitsToChar(c.bits)}</span> <span>${c.seq}</span>`;
      groupsList.appendChild(div);
    });
    
    // Alphabet
    'abcdefghijklmnopqrstuvwxyz'.split('').forEach(letter => {
      const bits = mapAtoBrailleBits[letter];
      if (bits !== undefined) {
        const div = document.createElement('div');
        div.className = 'ref-item';
        div.innerHTML = `<span style="font-size:20px">${bitsToChar(bits)}</span> <span>${letter}</span>`;
        alphabetChart.appendChild(div);
      }
    });
    
    // Add punctuation section
    const punctSection = document.createElement('div');
    punctSection.innerHTML = '<h4 style="grid-column: 1/-1; margin: 16px 0 8px 0;">Punctuation</h4>';
    alphabetChart.appendChild(punctSection);
    
    // Common punctuation
    const punctuation = ['.', ',', ';', ':', '!', '?', "'", '-', '/', '(', ')', '"', '#'];
    punctuation.forEach(punct => {
      const bits = mapAtoBrailleBits[punct];
      if (bits !== undefined) {
        const div = document.createElement('div');
        div.className = 'ref-item';
        div.innerHTML = `<span style="font-size:20px">${bitsToChar(bits)}</span> <span>${punct}</span>`;
        alphabetChart.appendChild(div);
      }
    });
  }
}

// High contrast toggle
document.getElementById('contrastBtn').addEventListener('click', () => {
  const root = document.documentElement;
  const current = root.getAttribute('data-contrast');
  const btn = document.getElementById('contrastBtn');
  
  if (current === 'high') {
    root.removeAttribute('data-contrast');
    btn.setAttribute('aria-pressed', 'false');
    btn.textContent = 'High Contrast';
  } else {
    root.setAttribute('data-contrast', 'high');
    btn.setAttribute('aria-pressed', 'true');
    btn.textContent = 'Normal Mode';
  }
});

// Dot size adjustment
document.getElementById('sizeRange').addEventListener('input', (e) => {
  document.documentElement.style.setProperty('--dot-size', e.target.value + 'px');
});

// Help modal
const helpModal = document.getElementById('helpModal');
document.getElementById('helpBtn').addEventListener('click', () => {
  helpModal.classList.add('show');
});

document.getElementById('closeHelp').addEventListener('click', () => {
  helpModal.classList.remove('show');
});

// Close modal on outside click
helpModal.addEventListener('click', (e) => {
  if (e.target === helpModal) {
    helpModal.classList.remove('show');
  }
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // Global shortcuts
  if (e.ctrlKey) {
    switch (e.key.toLowerCase()) {
      case 'b':
        e.preventDefault();
        document.getElementById('copyBraille').click();
        break;
      case 't':
        e.preventDefault();
        document.getElementById('copyPlain').click();
        break;
      case 'i':
        e.preventDefault();
        document.getElementById('importBtn').click();
        break;
      case 'e':
        e.preventDefault();
        document.getElementById('exportBtn').click();
        break;
    }
  }
  
  // Cell composer shortcuts (when not typing in textarea)
  if (!['TEXTAREA', 'INPUT'].includes(document.activeElement.tagName)) {
    if (['1','2','3','4','5','6'].includes(e.key)) {
      e.preventDefault();
      const btn = dotBtns.find(b => b.dataset.n === e.key);
      if (btn) btn.click();
    }
    
    if (e.key === 'Enter') {
      e.preventDefault();
      document.getElementById('insertToBraille').click();
    }
    
    if (e.key === 'Backspace') {
      e.preventDefault();
      clearCell();
    }
  }
  
  // Close modal with Escape
  if (e.key === 'Escape') {
    helpModal.classList.remove('show');
  }
});

// Initialize
updateBrailleOutput();
updatePlainOutput();
clearCell();

// Set initial placeholder text to test punctuation
plainIn.value = 'Hello, world! How are you? I\'m fine.';
updateBrailleOutput();
</script>
</body>
</html>